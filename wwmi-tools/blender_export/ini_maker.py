import hashlib

from typing import List, Dict, Union
from dataclasses import dataclass, field

from ..migoto_io.blender_interface.collections import *
from ..migoto_io.blender_interface.objects import *
from ..migoto_io.blender_interface.mesh import *

from ..migoto_io.buffers.byte_buffer import ByteBuffer

from ..migoto_io.ini_builder.IniBuilder import IniBuilder, IniSection, SectionType, IniSectionConditional

from ..extract_frame_data.metadata_format import ExtractedObject

from .object_merger import MergedObject, SkeletonType
from .metadata_collector import Version, ModInfo
from .texture_collector import Texture
    

def is_ini_edited(ini_path):
    '''
    Extracts defined SHA256 CHECKSUM from provided file and calculates sha256 of remaining lines
    If hashes match, it means that file doesn't contain any manual edits
    Allows to detect if mod.ini was manually edited to prevent accidental overwrite
    '''
    with open(ini_path, 'r') as f:
        data = list(f)

        # Extract data from expected location of checksum stamp
        checksum = data[-1].strip()

        # Ensure that checksum stamp has expected prefix 
        checksum_prefix = '; SHA256 CHECKSUM: '
        if not checksum.startswith(checksum_prefix):
            return False
        
        # Extract sha256 hash value from checksum stamp
        sha256 = checksum.replace(checksum_prefix, '')
        
        # Calculate sha256 hash of all lines above checksum stamp
        ini_data = data[:-1]
        ini_sha256 = hashlib.sha256(''.join(ini_data).encode('utf-8')).hexdigest()

        # Check if checksums are matching, different sha256 means data was edited
        if ini_sha256 != sha256:
            return True

        return False


@dataclass
class IniMaker:
    # Input
    mod_info: ModInfo
    extracted_object: ExtractedObject
    merged_object: MergedObject
    output_vertex_count: int
    buffers: Dict[str, ByteBuffer]
    textures: List[Texture]
    comment_code: bool
    unrestricted_custom_shape_keys: bool
    skeleton_scale: float
    # Output
    ini: IniBuilder = field(init=False)

    def __post_init__(self):
        self.ini = IniBuilder({
            'skip_comments': not self.comment_code
        })
        self.ini.header = (
            '; WWMI ALPHA-2 INI\n\n'
        )
        self.make_mod_state_group()
        if self.merged_object.shapekeys.vertex_count > 0:
            self.make_shape_keys_override_group()
        self.make_draw_calls_group()
        self.make_mod_info_group()
        self.make_texture_resources_group()
        if self.merged_object.shapekeys.vertex_count > 0:
            self.make_shape_keys_resources_group()
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            self.make_skeleton_resources_group()
        self.make_buffer_resources_group()
        self.make_autogenerated_group()

    def build(self):
        return self.with_checksum(self.ini.build())
    
    @staticmethod
    def with_checksum(lines):
        '''
        Calculates sha256 hash of provided lines and adds following looking entry to the end:
        '; SHA256 CHECKSUM: 401cafcfdb224c5013802b3dd5a5442df5f082404a9a1fed91b0f8650d604370' + '\n'
        Allows to detect if mod.ini was manually edited to prevent accidental overwrite
        '''
        sha256 = hashlib.sha256(lines.encode('utf-8')).hexdigest()
        lines += f'; SHA256 CHECKSUM: {sha256}' + '\n'
        return lines

    def make_mod_state_group(self):
        self.ini.set_group_header(0, (
            '; Mod State -------------------------\n\n'
        ))

        # [Constants]
        constants = IniSection(
            comment='Global variables used by entire mod',
            name='',
            section_type=SectionType.Constants,
        )
        self.ini.add_section(constants, 0)

        constants.body.add_comment(r'Allows WWMI to safely disable incompatible mod and notify user about it')
        constants.body.add_command(r'global $required_wwmi_version = %.2f' % self.mod_info.required_wwmi_version.as_float())

        constants.body.add_comment(r'Number of indices in original model')
        constants.body.add_command(r'global $object_guid = %d' % self.extracted_object.index_count)

        constants.body.add_comment(r'Number of vertices in custom model')
        constants.body.add_command(f'global $mesh_vertex_count = {self.output_vertex_count}')

        constants.body.add_comment(r'Number of shapekeyed vertices in custom model')
        constants.body.add_command(f'global $shapekey_vertex_count = {self.merged_object.shapekeys.vertex_count}')

        constants.body.add_comment(r'ID assigned to our mod by WWMI')
        constants.body.add_command(r'global $mod_id = -1000')

        if self.merged_object.skeleton_type == SkeletonType.Merged:
            constants.body.add_comment(r'Changes between 0 and 1 with every frame, used to run bone merging only once per frame for every component')
            constants.body.add_command(r'global $state_id = 0')

        constants.body.add_comment(r'Controls whether our mod is enabled, prevents any overrides from happening if $mod_enabled == 0')
        constants.body.add_comment(r'Prevents user from being crash-locked in case of incompatible WWMI version')
        constants.body.add_command(r'global $mod_enabled = 0')

        constants.body.add_comment(r'Indicates if our object was detected in previous frame')
        constants.body.add_command(r'global $object_detected = 0')

        # [Present]
        present = IniSection(
            comment='List of commands executed for every frame',
            name='',
            section_type=SectionType.Present,
        )
        self.ini.add_section(present, 0)

        object_detected_condition = present.body.add_command(IniSectionConditional())
        object_detected_body = object_detected_condition.add_if_clause('$object_detected')

        mod_enabled_condition = object_detected_body.add_command(IniSectionConditional())

        mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')
        mod_enabled_body.add_command('post $object_detected = 0')
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            mod_enabled_body.add_command('run = CommandListUpdateMergedSkeleton')

        mod_disabled_body = mod_enabled_condition.add_else_clause()
        mod_disabled_body.add_comment(r'Check if our mod is compatible with installed WWMI version (runs only once)')
        
        mod_id_condition = mod_disabled_body.add_command(IniSectionConditional())
        mod_id_body = mod_id_condition.add_if_clause('$mod_id == -1000')

        mod_id_body.add_comment(r'Pass required WWMI version along with mod metadata to WWMI')
        mod_id_body.add_command(r'run = CommandListRegisterMod')

        # [CommandListRegisterMod]
        register_mod = IniSection(
            comment='Contacts WWMI to check whether installed version is compatible with our mod',
            name='RegisterMod',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(register_mod, 0)

        register_mod.body.add_comment(r'Pass mod info variables to WWMI')
        register_mod.body.add_command(r'$\WWMIv1\required_wwmi_version = $required_wwmi_version')
        register_mod.body.add_command(r'$\WWMIv1\object_guid = $object_guid')

        register_mod.body.add_comment(r'Pass mod info resources to WWMI')
        register_mod.body.add_command(r'Resource\WWMIv1\ModName = ref ResourceModName')
        register_mod.body.add_command(r'Resource\WWMIv1\ModAuthor = ref ResourceModAuthor')
        register_mod.body.add_command(r'Resource\WWMIv1\ModDesc = ref ResourceModDesc')
        register_mod.body.add_command(r'Resource\WWMIv1\ModLink = ref ResourceModLink')
        register_mod.body.add_command(r'Resource\WWMIv1\ModLogo = ref ResourceModLogo')

        register_mod.body.add_comment(r'Register mod in WWMI')
        register_mod.body.add_command(r'run = CommandList\WWMIv1\RegisterMod')

        register_mod.body.add_comment(r'Read mod_id assigned to our mod by WWMI, incompatible mod will get `$mod_id == -1` assigned')
        register_mod.body.add_command(r'$mod_id = $\WWMIv1\mod_id')

        register_mod.body.add_comment(r'Enable our mod if WWMI assigned valid $mod_id to it')
        valid_mod_id_condition = register_mod.body.add_command(IniSectionConditional())
        valid_mod_id_body = valid_mod_id_condition.add_if_clause('$mod_id >= 0')
        valid_mod_id_body.add_command(r'$mod_enabled = 1')

        if self.merged_object.skeleton_type == SkeletonType.Merged:

            # [CommandListUpdateMergedSkeleton]
            update_merged_skeleton = IniSection(
                comment='Copes hard to make merged skeleton work with WuWa 1.1 pipeline',
                name='UpdateMergedSkeleton',
                section_type=SectionType.CommandList,
            )
            self.ini.add_section(update_merged_skeleton, 0)

            update_merged_skeleton.body.add_comment(r'Changes between 0 and 1 with every frame, used to run bone merging only once per frame for every component')
            state_id_condition = update_merged_skeleton.body.add_command(IniSectionConditional())
            state_id_if_body = state_id_condition.add_if_clause('$state_id')
            state_id_if_body.add_command(r'$state_id = 0')
            state_id_else_body = state_id_condition.add_else_clause()
            state_id_else_body.add_command(r'$state_id = 1')

            update_merged_skeleton.body.add_comment(r'Copy skeleton merged in previous frame to new buffer so we could force it to vs-cb4 slot')
            update_merged_skeleton.body.add_command(r'ResourceMergedSkeleton = copy ResourceMergedSkeletonRW')
            update_merged_skeleton.body.add_comment(r'Copy extra skeleton merged in previous frame to new buffer so we could force it to vs-cb3 slot')
            update_merged_skeleton.body.add_comment(r'Yes skeletons in vs-cb3 and vs-cb4 are slightly different, so we need to merge both for AA and outlines to work correctly')
            update_merged_skeleton.body.add_command(r'ResourceExtraMergedSkeleton = copy ResourceExtraMergedSkeletonRW')

    def make_mod_info_group(self):
        self.ini.set_group_header(1, (
            '; Resources: Mod Info -------------------------\n\n'
        ))

        # [ResourceModName]
        mod_name = IniSection(
            comment='Name of mod',
            name='ModName',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_name, 1)

        if len(self.mod_info.mod_name.strip()) != 0:
            mod_name.body.add_command(r'type = Buffer')
            mod_name.body.add_command(f'data = "{self.mod_info.mod_name}"')
        else:
            mod_name.body.add_persistent_comment(r'type = Buffer')
            mod_name.body.add_persistent_comment(f'data = "Unknown Mod Name"')

        # [ResourceModAuthor]
        mod_author = IniSection(
            comment='Name of mod author',
            name='ModAuthor',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_author, 1)

        if len(self.mod_info.mod_author.strip()) != 0:
            mod_author.body.add_command(r'type = Buffer')
            mod_author.body.add_command(f'data = "{self.mod_info.mod_author}"')
        else:
            mod_author.body.add_persistent_comment(r'type = Buffer')
            mod_author.body.add_persistent_comment(f'data = "Unknown Mod Author"')

        # [ResourceModDesc]
        mod_desc = IniSection(
            comment='Mod description',
            name='ModDesc',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_desc, 1)

        if len(self.mod_info.mod_desc.strip()) != 0:
            mod_desc.body.add_command(r'type = Buffer')
            mod_desc.body.add_command(f'data = "{self.mod_info.mod_desc}"')
        else:
            mod_desc.body.add_persistent_comment(r'type = Buffer')
            mod_desc.body.add_persistent_comment(f'data = "Empty Mod Description"')

        # [ResourceModLink]
        mod_link = IniSection(
            comment='Link to mod repository',
            name='ModLink',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_link, 1)

        if len(self.mod_info.mod_link.strip()) != 0:
            mod_link.body.add_command(r'type = Buffer')
            mod_link.body.add_command(f'data = "{self.mod_info.mod_link}"')
        else:
            mod_link.body.add_persistent_comment(r'type = Buffer')
            mod_link.body.add_persistent_comment(f'data = "Empty Mod Link"')

        # [ResourceModLogo]
        mod_logo = IniSection(
            comment='Texture file with 512x512 .dds (BC7 SRGB) mod logo',
            name='ModLogo',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(mod_logo, 1)

        if self.mod_info.mod_logo.is_file():
            mod_logo.body.add_command(r'filename = Textures/Logo.dds')
        else:
            mod_logo.body.add_persistent_comment(r'filename = Textures/Logo.dds')

    def make_draw_calls_group(self):
        self.ini.set_group_header(2, (
            '; Shading: Draw Call Stacks Processing -------------------------\n\n'
        ))

        if self.merged_object.skeleton_type == SkeletonType.Merged:

            # [TextureOverrideMarkBoneDataCB]
            mark_bone_data_cb = IniSection(
                comment='Marks Bones Data CB resource with arbitrary value 3381.7777',
                name='MarkBoneDataCB',
                section_type=SectionType.TextureOverride,
                hash=self.extracted_object.cb4_hash,
            )
            self.ini.add_section(mark_bone_data_cb, 2)
            mark_bone_data_cb.body.add_command(r'match_priority = 0')
            mark_bone_data_cb.body.add_command(r'filter_index = 3381.7777')

            # [CommandListMergeSkeleton]
            merge_skeleton = IniSection(
                comment='Update ResourceMergedSkeletonRW with bones data of current component',
                name='MergeSkeleton',
                section_type=SectionType.CommandList,
            )
            self.ini.add_section(merge_skeleton, 2)
       
            merge_skeleton.body.add_comment(r'Set custom scale for skeleton, changing size of the entire model')
            merge_skeleton.body.add_command(r'$\WWMIv1\custom_mesh_scale = %.2f' % self.skeleton_scale)

            merge_skeleton.body.add_comment(r'Pass constant buffer with real bone data to copy bones from')
            merge_skeleton.body.add_command(r'cs-cb8 = ref vs-cb4')
            merge_skeleton.body.add_comment(r'Pass buffer that gonna store real bone data of all components')
            merge_skeleton.body.add_command(r'cs-u6 = ResourceMergedSkeletonRW')
            merge_skeleton.body.add_comment(r'Run Skeleton Merger CS to merge real bone data of current component into ResourceMergedSkeletonRW')
            merge_skeleton.body.add_command(r'run = CustomShader\WWMIv1\SkeletonMerger')
            
            merge_skeleton.body.add_comment(r'Pass constant buffer with Anti-Aliasing bone data to copy bones from')
            merge_skeleton.body.add_command(r'cs-cb8 = ref vs-cb3')
            merge_skeleton.body.add_comment(r'Pass buffer that gonna store Anti-Aliasing bone data of all components')
            merge_skeleton.body.add_command(r'cs-u6 = ResourceExtraMergedSkeletonRW')
            merge_skeleton.body.add_comment(r'Run Skeleton Merger CS to merge Anti-Aliasing bone data of current component into ResourceExtraMergedSkeletonRW')
            merge_skeleton.body.add_command(r'run = CustomShader\WWMIv1\SkeletonMerger')

        # [CommandListTriggerResourceOverrides]
        replace_textures = IniSection(
            comment='Overrides textures via triggering [ResourceTextureX] sections by calling chechtextureoverride on ps-t slots',
            name='TriggerResourceOverrides',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(replace_textures, 2)
        
        replace_textures.body.add_comment(r'Trigger texture sections to replace texture with matching hash')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t0')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t1')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t2')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t3')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t4')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t5')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t6')
        replace_textures.body.add_command(r'CheckTextureOverride = ps-t7')

        if self.merged_object.skeleton_type == SkeletonType.Merged:
            replace_textures.body.add_comment(r'Trigger callbacks on bone data CBs to assign them filter_index')
            replace_textures.body.add_comment(r'These buffers cannot be replaced directly via `this` as their hash is widely used by many objects')
            replace_textures.body.add_command(r'CheckTextureOverride = vs-cb3')
            replace_textures.body.add_command(r'CheckTextureOverride = vs-cb4')

        # [CommandListOverrideSharedResources]
        replace_shared_resources = IniSection(
            comment='Overrides resources that are shared between VS calls',
            name='OverrideSharedResources',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(replace_shared_resources, 2)
        replace_shared_resources.body.add_comment(r'Store pointer to original buffer to restore original context on cleanup')
        replace_shared_resources.body.add_command(r'ResourceBypassVB0 = ref vb0')
        replace_shared_resources.body.add_comment(r'Override resources to make draw calls use custom meshes')
        replace_shared_resources.body.add_command(r'ib = ResourceIndexBuffer')
        if self.merged_object.shapekeys.vertex_count > 0 and self.unrestricted_custom_shape_keys:
            replace_shared_resources.body.add_command(r'vb0 = ResourceShapeKeyedPosition')
        else:
            replace_shared_resources.body.add_command(r'vb0 = ResourcePositionBuffer')
        replace_shared_resources.body.add_command(r'vb1 = ResourceVectorBuffer')
        replace_shared_resources.body.add_command(r'vb2 = ResourceTexcoordBuffer')
        replace_shared_resources.body.add_command(r'vb3 = ResourceColorBuffer')
        replace_shared_resources.body.add_command(r'vb4 = ResourceBlendBuffer')
        if self.merged_object.shapekeys.vertex_count > 0 and self.unrestricted_custom_shape_keys:
            replace_shared_resources.body.add_command(r'vb6 = null')

        if self.merged_object.skeleton_type == SkeletonType.Merged:

            replace_shared_resources.body.add_comment(r'Pass merged skeleton is resource matches marked Bones Data CB')

            cb3_condition = replace_shared_resources.body.add_command(IniSectionConditional())
            cb3_if_body = cb3_condition.add_if_clause('vs-cb3 == 3381.7777')
            cb3_if_body.add_command(r'vs-cb3 = ResourceExtraMergedSkeleton')

            cb4_condition = replace_shared_resources.body.add_command(IniSectionConditional())
            cb4_if_body = cb4_condition.add_if_clause('vs-cb4 == 3381.7777')
            cb4_if_body.add_command(r'vs-cb4 = ResourceMergedSkeleton')

        # [CommandListCleanupSharedResources]
        cleanup_shared_resources = IniSection(
            comment='Overrides resources that are shared between VS calls',
            name='CleanupSharedResources',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(cleanup_shared_resources, 2)
        cleanup_shared_resources.body.add_comment(r'Restore original vb0 so we can use its hash to match next call')
        cleanup_shared_resources.body.add_command(r'vb0 = ref ResourceBypassVB0')

        for component_id, component in enumerate(self.extracted_object.components):

            extracted_component = self.extracted_object.components[component_id]
            
            # [TextureOverrideComponentX]
            replace_component = IniSection(
                comment=f'Override draw calls for Component {component_id}',
                name=f'Component{component_id}',
                section_type=SectionType.TextureOverride,
                hash=self.extracted_object.vb0_hash,
            )
            self.ini.add_section(replace_component, 2)
            replace_component.body.add_command(f'match_first_index = {component.index_offset}')
            replace_component.body.add_command(f'match_index_count = {component.index_count}')
            
            if component_id == 0:
                replace_component.body.add_comment(r'Signal our mod that object is found on screen and we can start overriding it')
                replace_component.body.add_command(r'$object_detected = 1')
            
            mod_enabled_condition = replace_component.body.add_command(IniSectionConditional())
            mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

            if self.merged_object.skeleton_type == SkeletonType.Merged:
                mod_enabled_body.add_command(f'local $state_id_{component_id}')
                mod_enabled_body.add_comment(r'Limit bone merging to 1 time per frame')
                merge_bones_condition = mod_enabled_body.add_command(IniSectionConditional())
                merge_bones_condition_body = merge_bones_condition.add_if_clause(f'$state_id_{component_id} != $state_id')
                merge_bones_condition_body.add_comment(r'$state_id changes between 0 and 1 every frame')
                merge_bones_condition_body.add_command(f'$state_id_{component_id} = $state_id')
                merge_bones_condition_body.add_comment(r'Pass variables for SkeletonMerger CS')
                merge_bones_condition_body.add_command(r'$\WWMIv1\vg_offset = %d' % extracted_component.vg_offset)
                merge_bones_condition_body.add_command(r'$\WWMIv1\vg_count = %d' % extracted_component.vg_count)
                merge_bones_condition_body.add_comment(r'Merge bones of this components into ResourceMergedSkeleton')
                merge_bones_condition_body.add_command(r'run = CommandListMergeSkeleton')

                mod_enabled_body.add_comment(r'Override draw call if we have merged skeleton ready')
                override_draw_call_condition = mod_enabled_body.add_command(IniSectionConditional())
                # Here we redifine mod_enabled_body to make next ini maker calls write into merged skelly condtition
                mod_enabled_body = override_draw_call_condition.add_if_clause('ResourceMergedSkeleton !== null')

            mod_enabled_body.add_comment(r'Skip original draw call')
            mod_enabled_body.add_command(r'handling = skip')

            custom_component = self.merged_object.components[component_id]
            if len(custom_component.objects) > 0:

                mod_enabled_body.add_comment(r'Trigger by-hash resource overrides')
                mod_enabled_body.add_command(f'run = {replace_textures.get_section_title()}')
                
                mod_enabled_body.add_comment(r'Do by-slot resource overrides')
                mod_enabled_body.add_command(f'run = {replace_shared_resources.get_section_title()}')

                for obj in custom_component.objects:
                    mod_enabled_body.add_persistent_comment(f'Draw {obj.name}')
                    mod_enabled_body.add_command(f'drawindexed = {obj.index_count}, {obj.index_offset}, 0')

                mod_enabled_body.add_comment(r'Restore required parts of original context')
                mod_enabled_body.add_command(r'run = CommandListCleanupSharedResources')

            else:

                mod_enabled_body.add_comment(r'Trigger by-hash resource overrides')
                mod_enabled_body.add_persistent_comment(f'run = {replace_textures.get_section_title()}')
                
                mod_enabled_body.add_comment(r'Do by-slot resource overrides')
                mod_enabled_body.add_persistent_comment(f'run = {replace_shared_resources.get_section_title()}')

                mod_enabled_body.add_persistent_comment(f'Draw skipped: No matching custom components found')

                mod_enabled_body.add_comment(r'Restore required parts of original context')
                mod_enabled_body.add_persistent_comment(r'run = CommandListCleanupSharedResources')

    def make_texture_resources_group(self):
        self.ini.set_group_header(3, (
            '; Shading: Textures -------------------------\n\n'
        ))

        for texture_id, texture in enumerate(self.textures):

            texture_resoruce = IniSection(
                name=f'Texture{texture_id}',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(texture_resoruce, 3)

            texture_resoruce.body.add_command(f'filename = Textures/{texture.filename}')

            texture_override = IniSection(
                name=f'Texture{texture_id}',
                hash=texture.hash,
                section_type=SectionType.TextureOverride,
            )
            self.ini.add_section(texture_override, 3)

            texture_override.body.add_command(f'match_priority = 0')
            texture_override.body.add_command(f'this = {texture_resoruce.get_section_title()}')

    def make_shape_keys_override_group(self):
        self.ini.set_group_header(4, (
            '; Skinning: Shape Keys Override -------------------------\n\n'
        ))
        
        # [TextureOverrideShapeKeyOffsets]
        raise_shape_key_offsets = IniSection(
            comment='Increases size of UAV that stores shapekeyed vertices xyz offsets to support more vertices than original',
            name='ShapeKeyOffsets',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(raise_shape_key_offsets, 4)

        raise_shape_key_offsets.body.add_command(r'match_priority = 0')
        raise_shape_key_offsets.body.add_command(f'override_byte_stride = 24')
        raise_shape_key_offsets.body.add_command(f'override_vertex_count = $mesh_vertex_count')
                
        # [TextureOverrideShapeKeyScale]
        raise_shape_key_scale = IniSection(
            comment='Increases size of UAV that stores shapekeyed vertices multipliers to support more vertices than original',
            name='ShapeKeyScale',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.scale_hash,
        )
        self.ini.add_section(raise_shape_key_scale, 4)

        raise_shape_key_scale.body.add_command(r'match_priority = 0')
        raise_shape_key_scale.body.add_command(f'override_byte_stride = 4')
        raise_shape_key_scale.body.add_command(f'override_vertex_count = $mesh_vertex_count')

        
        # [CommandListSetupShapeKeys]
        setup_shapekeys = IniSection(
            comment='Updates ResourceShapeKeyCBRW that stores offsets of shapekeyed vertex lists, shape key values and multipliers',
            name='SetupShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(setup_shapekeys, 4)

        setup_shapekeys.body.add_comment(r'Pass 4 byte checksum of shapekey offsets to ensure that we only modify expected values')
        setup_shapekeys.body.add_command(f'$\WWMIv1\shapekey_checksum = {self.extracted_object.shapekeys.checksum}')
        setup_shapekeys.body.add_comment(r'Pass buffer with offsets for vertex lists of every shape key of custom model')
        setup_shapekeys.body.add_command(r'cs-t33 = ResourceShapeKeyOffsetBuffer')
        setup_shapekeys.body.add_comment(r'Pass buffer with custom values for every shape key, allows to control both custom and stock')
        setup_shapekeys.body.add_command(r'cs-u5 = ResourceCustomShapeKeyValuesRW')
        setup_shapekeys.body.add_comment(r'Pass buffer that gonna store result of calculations, required for Shape Key Loader CS to run')
        setup_shapekeys.body.add_command(r'cs-u6 = ResourceShapeKeyCBRW')

        setup_shapekeys.body.add_comment(r'Run ShapeKeyOverrider CS')
        setup_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyOverrider')
        
        # [CommandListLoadShapeKeys]
        load_shapekeys = IniSection(
            comment='Runs custom Shape Key Loader CS to, well, load shapekeys data from buffers',
            name='LoadShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(load_shapekeys, 4)

        load_shapekeys.body.add_comment(r'Pass number of shapekeyed vertices to adjust required threads count via dipatch_y')
        load_shapekeys.body.add_command(f'$\WWMIv1\shapekey_vertex_count = $shapekey_vertex_count')

        load_shapekeys.body.add_comment(r'Pass buffer with lists of per-vertex ids for every shape key')
        load_shapekeys.body.add_command(r'cs-t0 = ResourceShapeKeyVertexIdBuffer')
        load_shapekeys.body.add_comment(r'Pass buffer with lists of xyz per-vertex offsets for every shape key')
        load_shapekeys.body.add_command(r'cs-t1 = ResourceShapeKeyVertexOffsetBuffer')
        load_shapekeys.body.add_comment(r'Pass buffer with shape key vertex lists offsets, and shape key values & multipliers')
        load_shapekeys.body.add_command(r'cs-u6 = ResourceShapeKeyCBRW')

        load_shapekeys.body.add_comment(r'Run ShapeKeyLoader CS')
        load_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyLoader')

        # [TextureOverrideShapeKeyLoaderCallback]
        loader_cs_callback = IniSection(
            comment='Handles WWMI callback fired on original Shape Key Loader CS call',
            name='ShapeKeyLoaderCallback',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(loader_cs_callback, 4)

        loader_cs_callback.body.add_command(r'match_priority = 0')

        mod_enabled_condition = loader_cs_callback.body.add_command(IniSectionConditional())
        mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

        mod_enabled_body.add_comment(r'Ensure that callback has WWMI filter_index of Shape Key Loader CS assigned')
        loader_callback_condition = mod_enabled_body.add_command(IniSectionConditional())
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            loader_cs_body = loader_callback_condition.add_if_clause('cs == 3381.3333 && ResourceMergedSkeleton !== null')
        else:
            loader_cs_body = loader_callback_condition.add_if_clause('cs == 3381.3333')

        # It looks like we can skip checking for THREAD_GROUP_COUNT_Y as UAV hashes are unique for each object
        # loader_cs_body.add_comment(r'Ensure that dispatch_y of Shape Key Loader CS call matches one from dump')
        # run_loader_condition = loader_cs_body.add_command(IniSectionConditional())
        # run_loader_body = run_loader_condition.add_if_clause(f'THREAD_GROUP_COUNT_Y == {self.shapekeys.loader_dispatch_y}')
        loader_cs_body.add_comment(r'Skip handling of original Shape Key Loader CS call to modify dispatch_y value')
        loader_cs_body.add_command(r'handling = skip')
        loader_cs_body.add_comment(r'Run custom Shape Key Overrider CS to prepare shape key resources for loading')
        loader_cs_body.add_command(f'run = {setup_shapekeys.get_section_title()}')
        loader_cs_body.add_comment(r'Run custom Shape Key Loader CS to load shape key resources')
        loader_cs_body.add_command(f'run = {load_shapekeys.get_section_title()}')

        # [CommandListMultiplyShapeKeys]
        multiply_shapekeys = IniSection(
            comment='Runs custom Shape Key Loader CS to, well, load shapekeys data from buffers',
            name='MultiplyShapeKeys',
            section_type=SectionType.CommandList,
        )
        self.ini.add_section(multiply_shapekeys, 4)
        multiply_shapekeys.body.add_comment(r'Pass number of shapekeyed vertices to adjust required threads count via dipatch_y')
        multiply_shapekeys.body.add_command(r'$\WWMIv1\custom_vertex_count = $mesh_vertex_count')
        multiply_shapekeys.body.add_comment(r'Run custom Shape Key Multiplier CS to set deformation intensity')
        multiply_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyMultiplier')

        if self.unrestricted_custom_shape_keys:

            # [CommandListApplyShapeKeys]
            apply_shapekeys = IniSection(
                comment='Runs custom Shape Key Applier CS to apply calculated offsets to xyz position data, allowing to shapekey all components',
                name='ApplyShapeKeys',
                section_type=SectionType.CommandList,
            )
            self.ini.add_section(apply_shapekeys, 4)
            apply_shapekeys.body.add_comment(r'Pass buffer with per-vertex position data')
            apply_shapekeys.body.add_command(r'cs-t6 = ResourcePositionBuffer')
            apply_shapekeys.body.add_comment(r'Pass buffer to store calculation results')
            apply_shapekeys.body.add_command(r'cs-u6 = ResourcePositionRW')
            apply_shapekeys.body.add_comment(r'Run custom Shape Key Applier CS to add xyz offsets to position data')
            apply_shapekeys.body.add_command(r'run = CustomShader\WWMIv1\ShapeKeyApplier')
            apply_shapekeys.body.add_comment(r'Copy result to new buffer so we can force it to vb0 slot')
            apply_shapekeys.body.add_command(r'ResourceShapeKeyedPosition = copy ResourcePositionRW')
                
        # [TextureOverrideShapeKeyMultiplierCallback]
        multiplier_cs_callback = IniSection(
            comment='Handles WWMI callback fired on original Shape Key Multiplier CS call',
            name='ShapeKeyMultiplierCallback',
            section_type=SectionType.TextureOverride,
            hash=self.extracted_object.shapekeys.offsets_hash,
        )
        self.ini.add_section(multiplier_cs_callback, 4)

        multiplier_cs_callback.body.add_command(r'match_priority = 0')

        mod_enabled_condition = multiplier_cs_callback.body.add_command(IniSectionConditional())
        mod_enabled_body = mod_enabled_condition.add_if_clause('$mod_enabled')

        mod_enabled_body.add_comment(r'Ensure that callback has WWMI filter_index of Shape Key Multiplier CS assigned')
        multiplier_callback_condition = mod_enabled_body.add_command(IniSectionConditional())
        
        if self.merged_object.skeleton_type == SkeletonType.Merged:
            multiplier_cs_body = multiplier_callback_condition.add_if_clause('cs == 3381.4444 && ResourceMergedSkeleton !== null')
        else:
            multiplier_cs_body = multiplier_callback_condition.add_if_clause('cs == 3381.4444')

        # It looks like we can skip checking for THREAD_GROUP_COUNT_Y as UAV hashes are unique for each object
        # multiplier_cs_body.add_comment(r'Ensure that dispatch_y of Shape Key Multiplier CS call matches one from dump')
        # multiplier_condition = multiplier_cs_body.add_command(IniSectionConditional())
        # run_multiplier_body = multiplier_condition.add_if_clause(f'THREAD_GROUP_COUNT_Y == {self.shapekeys.multiplier_dispatch_y}')
        multiplier_cs_body.add_comment(r'Skip handling of original Shape Key Multiplier CS call to modify dispatch_y value')
        multiplier_cs_body.add_command(r'handling = skip')
        multiplier_cs_body.add_comment(r'Run custom Shape Key Multiplier CS to apply dynamic per-character multipliers')
        multiplier_cs_body.add_command(f'run = {multiply_shapekeys.get_section_title()}')
        if self.unrestricted_custom_shape_keys:
            multiplier_cs_body.add_comment(r'Runs custom Shape Key Applier CS to apply calculated offsets to xyz position data')
            multiplier_cs_body.add_command(f'run = {apply_shapekeys.get_section_title()}')
   
    def make_shape_keys_resources_group(self):
        self.ini.set_group_header(6, (
            '; Resources: Shape Keys Override -------------------------\n\n'
        ))

        if self.unrestricted_custom_shape_keys:

            # [ResourceShapeKeyedPosition]
            shapekeyed_position = IniSection(
                comment='Stores copy of ResourcePositionRW to force it into VB0',
                name='ShapeKeyedPosition',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(shapekeyed_position, 6)

            # [ResourcePositionRW]
            position_rw = IniSection(
                comment='Stores position data with applied per-vertex xyz offsets resulted from shape keys calculations',
                name='PositionRW',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(position_rw, 6)
            position_rw.body.add_command(r'type = RWBuffer')
            position_rw.body.add_command(r'format = R32_FLOAT')
            position_rw.body.add_command(r'stride = 12')
            position_rw.body.add_command(f'array = {12 * self.merged_object.shapekeys.vertex_count}')

        # [ResourceShapeKeyCBRW]
        shapekey_cbrw = IniSection(
            comment='Stores dynamically calculated CB required to override original Shape Keys CS call',
            name='ShapeKeyCBRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(shapekey_cbrw, 6)
        shapekey_cbrw.body.add_comment(r'Contains 128+128+8 values:')
        shapekey_cbrw.body.add_comment(r'* 128 uint: Shape Key offsets (continuous lists of vertex offsets)')
        shapekey_cbrw.body.add_comment(r'* 128 unorm: Shape Key values (range [0.0, 1.0])')
        shapekey_cbrw.body.add_comment(r'* 8 uint: Shape Key CS settings')
        shapekey_cbrw.body.add_command(r'type = RWBuffer')
        shapekey_cbrw.body.add_command(r'format = R32G32B32A32_UINT')
        shapekey_cbrw.body.add_comment(r'32 shapekey offsets, 32 shapekey values, 2 control flags')
        shapekey_cbrw.body.add_command(r'array = 66')

        # [ResourceCustomShapeKeyValuesRW]
        custom_values = IniSection(
            comment='Stores values of custom Shape Keys and overrides for original ones',
            name='CustomShapeKeyValuesRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(custom_values, 6)
        custom_values.body.add_comment(r'Contains 128 values, zero is shifted by 1.0 to the right')
        custom_values.body.add_comment(r'Expected value range is [1.0, 2.0]')
        custom_values.body.add_comment(r'* `0.0` means `no override`')
        custom_values.body.add_comment(r'* `1.0` means `override with zero`')
        custom_values.body.add_comment(r'* `2.0` means `override with one`')
        custom_values.body.add_command(r'type = RWBuffer')
        custom_values.body.add_command(r'format = R32G32B32A32_FLOAT')
        custom_values.body.add_comment(r'32 elements, 4 floats per element')
        custom_values.body.add_command(r'array = 32')

    def make_skeleton_resources_group(self):
        self.ini.set_group_header(7, (
            '; Resources: Skeleton Override -------------------------\n\n'
        ))

        # [ResourceMergedSkeleton]
        merged_skeleton = IniSection(
            comment='Stores a copy of full skeleton merged in previous frame',
            name='MergedSkeleton',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(merged_skeleton, 7)

        # [ResourceMergedSkeletonRW]
        merged_skeleton = IniSection(
            comment='Stores merged skeleton consisting of bones from all components, allows to make VG weights global',
            name='MergedSkeletonRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(merged_skeleton, 7)

        merged_skeleton.body.add_comment(r'Contains up to 256 bones')
        merged_skeleton.body.add_command(r'type = RWBuffer')
        merged_skeleton.body.add_command(r'format = R32G32B32A32_FLOAT')
        merged_skeleton.body.add_comment(r'256 bones, 3 elements per bone, 4 floats per element')
        merged_skeleton.body.add_command(r'array = 768')

        # [ResourceExtraMergedSkeleton]
        merged_skeleton = IniSection(
            comment='Stores a copy of full extra skeleton merged in previous frame',
            name='ExtraMergedSkeleton',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(merged_skeleton, 7)

        # [ResourceExtraMergedSkeletonRW]
        extra_merged_skeleton = IniSection(
            comment='Stores additional merged skeleton used by some shaders like Anti Aliasing',
            name='ExtraMergedSkeletonRW',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(extra_merged_skeleton, 7)

        extra_merged_skeleton.body.add_comment(r'Contains up to 256 bones')
        extra_merged_skeleton.body.add_command(r'type = RWBuffer')
        extra_merged_skeleton.body.add_command(r'format = R32G32B32A32_FLOAT')
        extra_merged_skeleton.body.add_comment(r'256 bones, 3 elements per bone, 4 floats per element')
        extra_merged_skeleton.body.add_command(r'array = 768')

    def make_buffer_resources_group(self):
        self.ini.set_group_header(8, (
            '; Resources: Buffers -------------------------\n\n'
        ))

        # [ResourceBypassVB0]
        resource_bypass_vb0 = IniSection(
            comment='Stores pointer to original vb0',
            name='BypassVB0',
            section_type=SectionType.Resource,
        )
        self.ini.add_section(resource_bypass_vb0, 8)

        for buffer_name, buffer in self.buffers.items():

            buffer_resource = IniSection(
                name=f'{buffer_name}Buffer',
                section_type=SectionType.Resource,
            )
            self.ini.add_section(buffer_resource, 8)
            buffer_resource.body.add_command(r'type = Buffer')
            buffer_resource.body.add_command(f'format = {buffer.layout.semantics[0].get_format()}')
            buffer_resource.body.add_command(f'stride = {buffer.layout.stride}')
            buffer_resource.body.add_command(f'filename = Meshes/{buffer_name}.buf')

    def make_autogenerated_group(self):
        msg = 'This mod.ini was automatically generated by WWMI Tools Blender addon v%s and requires WWMI v%s+ to function' % (
            self.mod_info.wwmi_tools_version, self.mod_info.required_wwmi_version
        )
        self.ini.set_group_footer(8, (
            '\n'
            '; Autogenerated -------------------------\n'
            '\n'
            f'; {msg}' + '\n'
            '; WWMI GameBanana: https://gamebanana.com/tools/17252' + '\n'
            '; WWMI Tools GameBanana: https://gamebanana.com/tools/17289' + '\n'
            '; WWMI GitHub: https://github.com/SpectrumQT/WWMI' + '\n'
            '; WWMI Tools GitHub: https://github.com/SpectrumQT/WWMI_Tools' + '\n'
            '; AGMG Modding Community Discord: https://discord.com/invite/agmg' + '\n'
            '\n'
        ))
    
